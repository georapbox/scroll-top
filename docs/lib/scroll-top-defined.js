var t, e, s, o; t = {}, e = "ScrollTop", s = function () { return n }, Object.defineProperty(t, e, { get: s, set: o, enumerable: !0, configurable: !0 }); const i = document.createElement("template"); i.innerHTML = '\n  <style>\n    :host {\n      display: block;\n      position: absolute;\n      top: 0;\n      right: 0;\n      width: 0;\n    }\n\n    .button {\n      position: fixed;\n      bottom: 16px;\n      right: 16px;\n      cursor: pointer;\n    }\n\n    .button--hidden {\n      opacity: 0;\n      visibility: hidden;\n    }\n  </style>\n\n  <button type="button" class="button button--hidden" part="button button--hidden">\n    <slot>Scroll to top</slot>\n  </button>\n'; class n extends HTMLElement { #t; #e; constructor() { super(), this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(i.content.cloneNode(!0)) } get visibleAfter() { return this.getAttribute("visible-after") } set visibleAfter(t) { this.setAttribute("visible-after", t) } get smoothScrolling() { return this.hasAttribute("smooth-scrolling") } set smoothScrolling(t) { t ? this.setAttribute("smooth-scrolling", "") : this.removeAttribute("smooth-scrolling") } get topOffset() { return Number(this.getAttribute("top-offset")) || 0 } set topOffset(t) { const e = Number(t) || 0; this.setAttribute("top-offset", e > 0 ? e : 0) } static get observedAttributes() { return ["visible-after"] } attributeChangedCallback(t, e, s) { "visible-after" === t && this.#s(s) } connectedCallback() { this.#o("visibleAfter"), this.#o("smoothScrolling"), this.#o("topOffset"), this.topOffset || (this.topOffset = 0), this.visibleAfter || (this.visibleAfter = "50vh"), this.#e = this.shadowRoot.querySelector("button"), this.#s(this.visibleAfter); try { this.#t = new IntersectionObserver((([t]) => { this.#e.classList.toggle("button--hidden", t.isIntersecting), this.#e.part.toggle("button--hidden", t.isIntersecting), this.dispatchEvent(new CustomEvent("scroll-top:visibility-change", { bubbles: !0, composed: !0, detail: { visible: !t.isIntersecting } })) })), this.#t.observe(this) } catch (t) { console.error(t) } this.#e.addEventListener("click", this.#i) } disconnectedCallback() { this.#t && (this.#t.disconnect(), this.#t = null), this.#e.removeEventListener("click", this.#i) } #s(t) { "string" == typeof t && (this.style.height = t) } #i = t => { t.preventDefault(); const e = { top: this.topOffset }; this.smoothScrolling && (e.behavior = "smooth"), document.scrollingElement.scrollTo(e) }; #o(t) { if (Object.prototype.hasOwnProperty.call(this, t)) { const e = this[t]; delete this[t], this[t] = e } } static defineCustomElement(t = "scroll-top") { "undefined" == typeof window || window.customElements.get(t) || window.customElements.define(t, n) } } n.defineCustomElement(); export { n as ScrollTop };
